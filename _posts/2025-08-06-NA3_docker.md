---
layout: post
title: News Archiving 3. Overview of VM, Container, Docker, and Kubernetes
date: 2025-08-06 20:55 +0900
categories: [Own Projects, Web Development]
tags:
description: 자동 뉴스 아카이빙 프로젝트
---


# 가상화가 없던 시절의 문제
1. 개발 환경 세팅이 오래걸림
2. 개발 환경 업데이트를 했을 때 의존성이 망가짐
3. 로컬에서 코드짠 걸 서버에서 실행만 해도 오류가 나는 경우 잦음. -> 배포나 서버를 옮길 때 여러 문제 발생
- 왜?
	: 환경마다 OS, 사용하는 프로그램, 환경변수 등이 모두 다름


# 해결방법 1. Virtual machine(VM)
- VM은 기존 OS위에 다른 OS를 설치하는 것.
- 구성
	1. Host OS : 실제 내 컴퓨터의 운영체제
	2. Hypervisor : 가상 머신을 실행하고 자원을 할당하는 프로그램
	3. Guest OS : 가상 머신 안에 설치된 운영체제
- 방법
	1. .iso(디스크 이미지 파일) 파일에 Bootloader(부팅가능영역), OS설치 프로그램, OS파일 시스템(패키지들)을 담아서 저장
	2. VM을 부팅하면 .iso로부터 설치를 시작해서 진짜 OS처럼 작동
- Hypervisor 종류
	1. 하드웨어에 설치된 Hypervisor : Microsoft Hyper-V, VMware ESXi
	2. 소프트웨어로 된 Hypervisor : VirtualBox, VMware Workstation, Parallels
- 특징
	- 그러나 매우 무겁고 성능이 좋지 않아서 자주 쓰이지 않음
	- VM 환경을 만드는 iso파일에 OS가 들어가기 때문에 무겁고 성능이 안좋아짐
- 참고) Hypervisor의 가상화 방식
	- 명령
		1. Full Virtualization (Trap-and-Emulate) : Guest OS의 명령을 가로채서 대신 실행
		2. Paravirtualization (Hypercall) : Guest OS를 가상화에 맞게 수정해서 Hypervisor에 명령 내림
		3. Hardware-assisted Virtualization : CPU 자체에 가상화를 위한 모드 추가
	- 메모리 : Shadow Page Table, Extended Page Table 등
	- 디스크 : 실제 파일을 가상 하드디스크처럼 마운트 (.vdi)
	- 네트워크 : 가상 NIC를 만들어서 실제 NIC와 브릿지 연결

![docker.png]



# 해결방법 2. Linux Container
- 리눅스 커널은 원래부터 여러 사용자/프로세스 격리를 지원함
- 하나의 커널만 유지한 채 프로세스 수준에서 격리 (불필요한 OS만드는작업 및 Infra를 독립적으로 나눌 필요가 없음)
	- > 독립적인 프로그램처럼 독립된 환경을 제공하면서 가볍고 빠르며 확장성이 좋음

- 핵심 기술
	- Namespaces : 자신만의 세상을 가진 것처럼 보이게함 (PID, 파일시스템, 네트워크, 유저 등 격리)
	- cgroups (Control Groups) : 프로세스마다 CPU, 메모리 등 자원제한 및 모니터링

- 단점
	- 컨테이너를 직점 만들려면
		- chroot로 루트 파일시스템 만들고
		- namespace, cgroup을 직접 설정하고
		- 실행파일 복사하고 의존성 맞추고 네트워크 설정을 해야 함.
	-> 자동화 하는 도커의 등장



# Docker란?
Linux container를 기반으로 만든 OS레벨 가상화 구현을 도와주는 프로그램
- OS를 따로 설치하지 않음. 참조만 되어 있음. 런타임 하고 미들웨어의 용량만 있으면 돼서, VM에 비해 매우 가벼워짐. Host OS의 리소스를 이용

- 도커 구성 요소
	- Docker daemon(Docker Engine) : 이미지, 컨테이너, 네트워크 등 도커 객체 및 서비스 실행, 관리하는 서버
	- Docker CLI, GUI : 사용자가 명령어로 container를 조작
	- Docker Image : 실행 가능한 앱 패키지 (코드 + 의존성 + 설정)
	- Docker Container : 이미지를 실행한 인스턴스 (VM의 iso와 비슷한 느낌)
	- Dockerfile : 이미지를 코드처럼 정의하는 파일
	- Docker Registry : 도커 이미지를 저장.하는 곳. Docker hub라는 공용 레지스트리와 private 레지스트리가 있다. 


### Docker 실행 방법
- 직접 만들고 싶다면, Dockerfile에 설치할 OS, 프로그램, 라이브러리, 실행할 코드를 형식에 맞추어 작성하고, Docker engine에서 그걸 실행하면 됨
- 혹은 Docker Hub에 있는 이미지를 다운받아 사용

- 예시) SQL 도커 이용하기
```
docker run -d --name [컨테이너이름] -e MYSQL_ROOT_PASSWORD=[db비밀번호] -e MYSQL_DATABASE=[db이름] -p 3306:3306 -v [로컬db저장경로]:/var/lib/mysql mysql:8 --mysql-native-password=ON
```
- 명령어 설명
	- `docker run` : 도커에서 새로운 컨테이너 생성 및 실행
	- `-d` : detach모드로 컨테이너 실행 (터미널 점유하지 않고 백그라운드로 실행)
	- `--name [컨테이너이름]` : "컨테이너이름" 이라는 이름의 컨테이너 실행. 이름 지정안하면 랜덤으로 지정됨
	- `-e `: 컨테이너에서 사용할 환경변수 설정
	- `MYSQL_ROOT_PASSWORD=[db비밀번호]`: MySQL 서버의 root 계정 비밀번호를 설정하는 환경변수
	- `MYSQL_DATABASE=[db이름] `: 컨테이너 실행 시, 자동으로 생성할 데이터베이스 이름
	- `-p [호스트 포트]:[컨테이너 포트] `: MySQL 기본 포트는 3306이므로 두 3306 포트 연결
	- `-v [로컬db저장경로]:/var/lib/mysql` :  volume mount를 해서 MYSQL의 db 파일들이 로컬에 직접 저장되도록 연결 (이걸 안하면 컨테이너가 종료되면 DB도 같이 사라짐)
	- `mysql:8` : 사용할 docker 이미지 지정 (MySQL 8버전. Docker Hub에 있음)
	- `mysql-native-password=ON` : MySQL 인증 플러그인 설정. (MySQL 8부터 기본 인증 플러그인이 caching_sha2_password로 변경됐는데 일부 클라이언트 툴이 이를 지원하지 않아서 이걸 설정해주면 호환성 좋음)


### Docker의 장, 단점
- Docker Layer
	- 도커의 이미지는 layered 되어서, A이미지와 B이미지를 같이 쓰고 싶으면 둘다 설치하면 된다. 이미지가 변한다면 변한 부분만 바꾸면 된다.
	- 예시)
  	- Layer 1: Base 우분투 레이어 설치
  	- Layer 2: 우분투 OS에서 사용하는 패키지 설치
  	- Layer 3: 파이썬 등 프로그래밍 환경 설치
  	- Layer 4: 소스코드 작성
  	- Layer 5: Entrypoint 업데이트
- Docker Hub
	- Ubuntu, SQL 등 자주 사용되는 이미지나, 누군가 배포한 이미지가 있는 public 저장소 (Github 같은 느낌)
	- 다른사람이 배포한 container를 쉽게 가져올 수 있음
- MSA가 가능해짐 : 서버 기능을 나누어서 여러 프로그램으로 작성
- 버전 관리와 배포가 쉬워짐

- 단점
	- Docker 비용에 따라 서버 관리비용 증가
	- 리눅스가 아닌 OS에서는 성능 감소. (Linux container를 만들 때는 VM을 써야 함)
	- 모든 컨테이너가 호스트 커널 공유 → 완전한 보안 격리가 아님.
	- 클러스터링을 위한 swarm과 docker hub가 밀접하게 연결되어있는 monolithic 구조에 비해 특정 태스크에 특화된 더 가벼운 containered, helm, k8s 등 존재
	- 벤더 종속성 (오픈 소스가 아님)
  	- 대안 : Podman(보안중시), containered(경량화 및 확장성 좋음, k8s에서 채택), CRI-O(k8s를 위한 간결한 설계), Lima&Finch(Mac에 최적화됨)
	- 이미지 사이즈가 커질 수 있음
	- 복잡한 오케스트레이션은 어렵다 → Kubernetes 등장



# Kubernetes(k8s)
수많은 컨테이너를 자동으로 배치, 스케일링, 복구, 업데이트해주는 오케스트레이터
- 구글이 오픈소스로 공개

- 구조
	- - Pod
		- k8s에서 컨테이너를 실행하는 가장 작은 단위
		- 1개 이상의 컨테이너를 하나의 묶음(Pod)으로 실행
		- 같은 Pod안 컨테이너는 IP, 볼륨 등을 공유
	- Node
		- 실제 Pod(컨테이너들)가 실행되는 서버
		- k8s 클러스터는 여러 개의 Node로 구성됨
	- Master / Control Plane
		- 전체 클러스터를 제어하는 두뇌
		- 어떤 Pod를 어디 Node에 배치할 지 결정

- 작동 방법
	1. 사용자가 "Python 서버 3개 실행해줘"라고 선언
	2. Kubernetes가 Pod 3개를 만들고, 각 Node에 분산 배치
	3. 하나가 죽으면 → 자동으로 새 Pod 생성해서 복구
	4. 트래픽 많아지면 → Pod 수 자동 증가 (Horizontal Scaling)
	5. 버전 바꾸고 싶으면 → Rolling Update로 순차 교체


# 그래서?
내 프로젝트에도 도커를 써볼 생각이다. 그 이유는 반복적인 크롤링을 하기 위해선 클라우드 환경에서 서버를 쓰게 될 텐데, 그럼 로컬과 환경이 달라지기 때문에 도커가 필요하다고 느꼈다.

# Reference
https://www.youtube.com/watch?v=e0koWWAmXSk
https://velog.io/@geunwoobaek/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EB%B0%8F-%EB%8F%84%EC%BB%A4-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC
https://seosh817.tistory.com/345
https://hipopatamus.tistory.com/109
https://www.youtube.com/watch?v=NGAxHC0f1wU&ab_channel=%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%B0%A916
심화: https://colevelup.tistory.com/30
